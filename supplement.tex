\subsection{Limits: The Gruntz Algorithm}

\input{gruntz.tex}

% Series module (Formal Power Series, Fourier Series)
\subsection{Series}

\input{series.tex}

% Logic module
\subsection{Logic}

\input{logic}

\subsection{Diophantine Equations}

\input{diophantine}

% Sets
\subsection{Sets}
\input{sets}

\subsection{Category Theory}
\input{categories}

\subsection{SymPy Gamma}\label{sympy-gamma}

\input{gamma}

\subsection{SymPy Live}\label{sympy-live}

\input{live}

\subsection{Comparison with Mathematica}

\input{comparison_with_mma}

\subsection{Other Projects that use SymPy}

\input{other_projects_that_use_sympy}


\subsection{Tensors}

\input{tensors}


\subsection{Numerical simplification}

The \texttt{nsimplify} function in SymPy
(a wrapper of \texttt{identify} in mpmath)
attempts to find a simple symbolic
expression that evaluates to the same numerical value as the given
input.
It works by applying a few simple transformations
(including square roots, reciprocals, logarithms and exponentials) to
the input and, for each transformed value,
using the PSLQ algorithm~\cite{Ferguson1999} to search for
a matching algebraic number or, optionally, a linear combination
of user-provided base constants (such as $\pi$).

\begin{verbatim}
>>> t = 1 / (sin(pi/5)+sin(2*pi/5)+sin(3*pi/5)+sin(4*pi/5))**2
>>> nsimplify(t)
-2*sqrt(5)/5 + 1
>>> nsimplify(pi, tolerance=0.01)
22/7
>>> nsimplify(1.783919626661888, [pi], tolerance=1e-12)
pi/(-1/3 + 2*pi/3)
\end{verbatim}


\subsection{Examples}

\subsubsection{Simplification}

\noindent \texttt{expand}
\begin{verbatim}
>>> expand((x + y)**3)
x**3 + 3*x**2*y + 3*x*y**2 + y**3
\end{verbatim}

\noindent \texttt{factor}
\begin{verbatim}
>>> factor(x**3 + 3*x**2*y + 3*x*y**2 + y**3)
(x + y)**3
\end{verbatim}

\noindent \texttt{collect}
\begin{verbatim}
>>> collect(y*x**2 + 3*x**2 - x*y + x - 1, x)
x**2*(y + 3) + x*(-y + 1) - 1
\end{verbatim}

\noindent \texttt{cancel}
\begin{verbatim}
>>> cancel((x**2 + 2*x + 1)/(x**2 - 1))
(x + 1)/(x - 1)
\end{verbatim}

\noindent \texttt{apart}
\begin{verbatim}
>>> apart((x**3 + 4*x - 1)/(x**2 - 1))
x + 3/(x + 1) + 2/(x - 1)
\end{verbatim}

\noindent \texttt{trigsimp}
\begin{verbatim}
>>> trigsimp(cos(x)**2*tan(x) - sin(2*x))
-sin(2*x)/2
\end{verbatim}


\subsubsection{Polynomials}
%% TODO - explain why these matter
\noindent Factorization:
\begin{verbatim}
>>> t = symbols("t")
>>> f = (2115*x**4*y + 45*x**3*z**3*t**2 - 45*x**3*t**2 - 423*x*y**4 -
...      47*x*y**3 + 141*x*y*z**3 + 94*x*y*z*t - 9*y**3*z**3*t**2 +
...      9*y**3*t**2 - y**2*z**3*t**2 + y**2*t**2 + 3*z**6*t**2 +
...      2*z**4*t**3 - 3*z**3*t**2 - 2*z*t**3)
>>> factor(f)
(t**2*z**3 - t**2 + 47*x*y)*(2*t*z + 45*x**3 - 9*y**3 - y**2 + 3*z**3)
\end{verbatim}

\noindent Gr\"{o}bner bases:
\begin{verbatim}
>>> x0, x1, x2 = symbols('x:3')
>>> I = [x0 + 2*x1 + 2*x2 - 1,
...      x0**2 + 2*x1**2 + 2*x2**2 - x0,
...      2*x0*x1 + 2*x1*x2 - x1]
>>> groebner(I, order='lex')
GroebnerBasis([7*x0 - 420*x2**3 + 158*x2**2 + 8*x2 - 7,
7*x1 + 210*x2**3 - 79*x2**2 + 3*x2,
84*x2**4 - 40*x2**3 + x2**2 + x2], x0, x1, x2, domain='ZZ', order='lex')
\end{verbatim}

\noindent Root isolation:
\begin{verbatim}
>>> f = 7*z**4 - 19*z**3 + 20*z**2 + 17*z + 20
>>> intervals(f, all=True, eps=0.001)
([],
 [((-425/1024 - 625*I/1024, -1485/3584 - 2185*I/3584), 1),
  ((-425/1024 + 2185*I/3584, -1485/3584 + 625*I/1024), 1),
  ((3175/1792 - 2605*I/1792, 1815/1024 - 10415*I/7168), 1),
  ((3175/1792 + 10415*I/7168, 1815/1024 + 2605*I/1792), 1)])
\end{verbatim}

\subsubsection{Solvers}


\noindent Single solution:
\begin{verbatim}
>>> solveset(x - 1, x)
{1}
\end{verbatim}

\noindent Finite solution set, quadratic equation:
\begin{verbatim}
>>> solveset(x**2 - pi**2, x)
{-pi, pi}
\end{verbatim}

\noindent No solution:
\begin{verbatim}
>>> solveset(1, x)
EmptySet()
\end{verbatim}

\noindent Interval solution:
\begin{verbatim}
>>> solveset(x**2 - 3 > 0, x, domain=S.Reals)
(-oo, -sqrt(3)) U (sqrt(3), oo)
\end{verbatim}

\noindent Infinitely many solutions:
% SymPy 1.0 sstr() prints S.Complexes incorrectly
% no-doctest
\begin{verbatim}
>>> solveset(x - x, x, domain=S.Reals)
(-oo, oo)
>>> solveset(x - x, x, domain=S.Complexes)
S.Complexes
\end{verbatim}

\noindent Linear systems (\texttt{linsolve})
\begin{verbatim}
>>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])
>>> b = Matrix([3, 6, 9])
>>> linsolve((A, b), x, y, z)
{(-1, 2, 0)}
>>> linsolve(Matrix(([1, 1, 1, 1], [1, 1, 2, 3])), (x, y, z))
{(-y - 1, y, 2)}
\end{verbatim}

Below are examples of \texttt{solve} applied to problems not yet handled by \texttt{solveset}.

\noindent Nonlinear (multivariate) system of equations (the intersection of a circle
and a parabola):
\begin{verbatim}
>>> solve([x**2 + y**2 - 16, 4*x - y**2 + 6], x, y)
[(-2 + sqrt(14), -sqrt(-2 + 4*sqrt(14))),
 (-2 + sqrt(14), sqrt(-2 + 4*sqrt(14))),
 (-sqrt(14) - 2, -I*sqrt(2 + 4*sqrt(14))),
 (-sqrt(14) - 2, I*sqrt(2 + 4*sqrt(14)))]
\end{verbatim}

\noindent Transcendental equations:
\begin{verbatim}
>>> solve((x + log(x))**2 - 5*(x + log(x)) + 6, x)
[LambertW(exp(2)), LambertW(exp(3))]
>>> solve(x**3 + exp(x))
[-3*LambertW((-1)**(2/3)/3)]
\end{verbatim}

\subsubsection{Matrices}

\noindent Matrix expressions
\begin{verbatim}
>>> m, n, p = symbols("m, n, p", integer=True)
>>> R = MatrixSymbol("R", m, n)
>>> S = MatrixSymbol("S", n, p)
>>> T = MatrixSymbol("T", m, p)
>>> U = R*S + 2*T
>>> U.shape
(m, p)
>>> U[0, 1]
2*T[0, 1] + Sum(R[0, _k]*S[_k, 1], (_k, 0, n - 1))
\end{verbatim}

\noindent Block Matrices
\begin{verbatim}
>>> n, m, l = symbols('n m l')
>>> X = MatrixSymbol('X', n, n)
>>> Y = MatrixSymbol('Y', m ,m)
>>> Z = MatrixSymbol('Z', n, m)
>>> B = BlockMatrix([[X, Z], [ZeroMatrix(m, n), Y]])
>>> B
Matrix([
[X, Z],
[0, Y]])
>>> B[0, 0]
X[0, 0]
>>> B.shape
(m + n, m + n)
\end{verbatim}
